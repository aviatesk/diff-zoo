<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Forward · diff-zoo</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">diff-zoo</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">README</a></li><li><span class="tocitem">Notebooks</span><ul><li><a class="tocitem" href="../intro/">Intro</a></li><li><a class="tocitem" href="../backandforth/">Back &amp; Forth</a></li><li class="is-active"><a class="tocitem" href>Forward</a><ul class="internal"><li><a class="tocitem" href="#Dual-Numbers"><span>Dual Numbers</span></a></li><li><a class="tocitem" href="#Perturbation-Confusion"><span>Perturbation Confusion</span></a></li><li><a class="tocitem" href="#More-on-Dual-Numbers"><span>More on Dual Numbers</span></a></li></ul></li><li><a class="tocitem" href="../tracing/">Tracing</a></li><li><a class="tocitem" href="../reverse/">Reverse</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Notebooks</a></li><li class="is-active"><a href>Forward</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Forward</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/diff-zoo/blob/master/src/forward.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementing-Forward-Mode"><a class="docs-heading-anchor" href="#Implementing-Forward-Mode">Implementing Forward Mode</a><a id="Implementing-Forward-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-Forward-Mode" title="Permalink"></a></h1><p>In the <a href="intro/">intro notebook</a> we covered forward-mode differentiation thoroughly, but we don&#39;t yet have a real implementation that can work on our programs. Implementing AD effectively and efficiently is a field of its own, and we&#39;ll need to learn a few more tricks to get off the ground.</p><pre><code class="language-julia">include(&quot;utils.jl&quot;);</code></pre><p>Up to now, we have differentiated things by creating a new Wengert list which contains parts of the original expression.</p><pre><code class="language-julia">y = Wengert(:(5sin(log(x))))
derive(y, :x)</code></pre><pre class="documenter-example-output">Wengert List
y1 = log(x)
y2 = sin(y1)
y3 = 5 * y2
y4 = 1 / x
y5 = cos(y1)
y6 = y5 * y4
y7 = 5 * y6
</pre><p>We&#39;re now going to explicitly split our lists into two pieces: the original expression, and a new one which only calculates derivatives (but might refer back to values from the first). For example:</p><pre><code class="language-julia">y = Wengert(:(5sin(log(x))))</code></pre><pre class="documenter-example-output">Wengert List
y1 = log(x)
y2 = sin(y1)
y3 = 5 * y2
</pre><pre><code class="language-julia">dy = derive(y, :x, out = Wengert(variable = :dy))</code></pre><pre class="documenter-example-output">Wengert List
dy1 = 1 / x
dy2 = cos(y1)
dy3 = dy2 * dy1
dy4 = 5 * dy3
</pre><pre><code class="language-julia">Expr(dy)</code></pre><pre class="documenter-example-output">:((5 * (cos(y1) * (1 / x)),;))</pre><p>If we want to distinguish them, we can call <code>y</code> the <em>primal code</em> and <code>dy</code> the <em>tangent code</em>. Nothing fundamental has changed here, but it&#39;s useful to organise things this way.</p><p>Almost all of the subtlety in differentiating programs comes from a mathematically trivial question: in what order do we evaluate the statements of the Wengert list? We have discussed the <a href="backandforth/">forward/reverse</a> distinction, but even once that choice is made, we have plenty of flexibility, and those choices can affect efficiency.</p><p>For example, imagine if we straightforwardly evaluate <code>y</code> followed by <code>dy</code>. If we only cared about the final output of <code>y</code>, this would be no problem at all, but in general <code>dy</code> also needs to re-use variables like <code>y1</code> (or possibly any <span>$y_i$</span>). If our primal Wengert list has, say, a billion instructions, we end up having to store a billion intermediate <span>$y_i$</span> before we run our tangent code.</p><p>Alternatively, one can imagine running each instruction of the tangent code as early as possible; as soon as we run <code>y1 = log(x)</code>, for example, we know we can run <code>dy2 = cos(y1)</code> also. Then our final, combined program would look something like this:</p><pre><code class="language-julia">y0 = x
dy = 1
y1 = log(y0)
dy = dy/y0
y2 = cos(y1)
dy = dy*sin(y1)
  ...</code></pre><p>Now we can throw out <code>y1</code> soon after creating it, and we no longer have to store those billion intermediate results.</p><p>The ability to do this is a very general property of forward differentiation; once we run <span>$a = f(b)$</span>, we can then run <span>$\frac{da}{dx} = \frac{da}{db} \frac{db}{dx}$</span> using only <code>a</code> and <code>b</code>. It&#39;s really just a case of replacing basic instructions like <code>cos</code> with versions that calculate both the primal and tangent at once.</p><h2 id="Dual-Numbers"><a class="docs-heading-anchor" href="#Dual-Numbers">Dual Numbers</a><a id="Dual-Numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Dual-Numbers" title="Permalink"></a></h2><p>Finally, the trick that we&#39;ve been building up to: making our programming language do this all for us! Almost all common languages – with the notable exception of C – provide good support for <em>operator overloading</em>, which allows us to do exactly this replacement.</p><p>To start with, we&#39;ll make a container that holds both a <span>$y$</span> and a <span>$\frac{dy}{dx}$</span>, called a <em>dual number</em>.</p><pre><code class="language-julia">struct Dual{T&lt;:Real} &lt;: Real
  x::T
  ϵ::T
end

Dual(1, 2)</code></pre><pre class="documenter-example-output">Main.__atexample__named__forward.Dual{Int64}(1, 2)</pre><pre><code class="language-julia">Dual(1.0,2.0)</code></pre><pre class="documenter-example-output">Main.__atexample__named__forward.Dual{Float64}(1.0, 2.0)</pre><p>Let&#39;s print it nicely.</p><pre><code class="language-julia">Base.show(io::IO, d::Dual) = print(io, d.x, &quot; + &quot;, d.ϵ, &quot;ϵ&quot;)

Dual(1, 2)</code></pre><pre class="documenter-example-output">1 + 2ϵ</pre><p>And add some of our rules for differentiation. The rules have the same basic pattern-matching structure as the ones we originally applied to our Wengert list, just with different notation.</p><pre><code class="language-julia">import Base: +, -, *, /
a::Dual + b::Dual = Dual(a.x + b.x, a.ϵ + b.ϵ)
a::Dual - b::Dual = Dual(a.x - b.x, a.ϵ - b.ϵ)
a::Dual * b::Dual = Dual(a.x * b.x, b.x * a.ϵ + a.x * b.ϵ)
a::Dual / b::Dual = Dual(a.x / b.x, (b.x * a.ϵ - a.x * b.ϵ) / b.x^2)

Base.sin(d::Dual) = Dual(sin(d.x), d.ϵ * cos(d.x))
Base.cos(d::Dual) = Dual(cos(d.x), - d.ϵ * sin(d.x))

Dual(2, 2) * Dual(3, 4)</code></pre><pre class="documenter-example-output">6 + 14ϵ</pre><p>Finally, we&#39;ll hook into Julia&#39;s number promotion system; this isn&#39;t essential to understand, but just makes it easier to work with Duals since we can now freely mix them with other number types.</p><pre><code class="language-julia">Base.convert(::Type{Dual{T}}, x::Dual) where T = Dual(convert(T, x.x), convert(T, x.ϵ))
Base.convert(::Type{Dual{T}}, x::Real) where T = Dual(convert(T, x), zero(T))
Base.promote_rule(::Type{Dual{T}}, ::Type{R}) where {T,R} = Dual{promote_type(T,R)}

Dual(1, 2) * 3</code></pre><pre class="documenter-example-output">3 + 6ϵ</pre><p>We already have enough to start taking derivatives of some simple functions. If we pass a dual number into a function, the <span>$\epsilon$</span> component represents the derivative.</p><pre><code class="language-julia">f(x) = x / (1 + x*x)

f(Dual(5., 1.))</code></pre><pre class="documenter-example-output">0.19230769230769232 + -0.03550295857988166ϵ</pre><p>We can make a utility which allows us to differentiate any function.</p><pre><code class="language-julia">D(f, x) = f(Dual(x, one(x))).ϵ

D(f, 5.)</code></pre><pre class="documenter-example-output">-0.03550295857988166</pre><p>Dual numbers seem pretty scarcely related to all the Wengert list stuff we were talking about earlier. But we need take a closer look at how this is working. To start with, look at Julia&#39;s internal representation of <code>f</code>.</p><pre><code class="language-julia">@code_typed f(1.0)</code></pre><pre class="documenter-example-output">CodeInfo(
1 ─ %1 = Base.mul_float(x, x)::Float64
│   %2 = Base.sitofp(Float64, 1)::Float64
│   %3 = Base.add_float(%2, %1)::Float64
│   %4 = Base.div_float(x, %3)::Float64
└──      return %4
) =&gt; Float64</pre><p>This is just a Wengert list! Though the naming is a little different – <code>mul_float</code> rather than the more general <code>*</code> and so on – it&#39;s still essentially the same data structure we were working with earlier. Moreover, you&#39;ll recognise the code for the derivative, too!</p><pre><code class="language-julia">@code_typed D(f, 1.0)</code></pre><pre class="documenter-example-output">CodeInfo(
1 ─ %1  = Base.mul_float(x, x)::Float64
│   %2  = Base.mul_float(x, 1.0)::Float64
│   %3  = Base.mul_float(x, 1.0)::Float64
│   %4  = Base.add_float(%2, %3)::Float64
│   %5  = Base.sitofp(Float64, 1)::Float64
│   %6  = Base.add_float(%5, %1)::Float64
│   %7  = Base.add_float(0.0, %4)::Float64
│   %8  = Base.mul_float(%6, 1.0)::Float64
│   %9  = Base.mul_float(x, %7)::Float64
│   %10 = Base.sub_float(%8, %9)::Float64
│   %11 = Base.mul_float(%6, %6)::Float64
│   %12 = Base.div_float(%10, %11)::Float64
└──       return %12
) =&gt; Float64</pre><p>This code is again the same as the Wengert list derivative we worked out at the very beginning of this handbook. The order of operations is just a little different, and there&#39;s the odd missing or new instruction due to the different set of optimisations that Julia applies. Still, we have not escaped our fundamental symbolic differentiation algorithm, just tricked the compiler into doing most of the work for us.</p><pre><code class="language-julia">derive(Wengert(:(sin(cos(x)))), :x)</code></pre><pre class="documenter-example-output">Wengert List
y1 = cos(x)
y2 = sin(y1)
y3 = sin(x)
y4 = -y3
y5 = cos(y1)
y6 = y5 * y4
</pre><pre><code class="language-julia">@code_typed D(x -&gt; sin(cos(x)), 0.5)</code></pre><pre class="documenter-example-output">CodeInfo(
1 ─ %1 = invoke Main.__atexample__named__forward.cos(_3::Float64)::Float64
│   %2 = invoke Main.__atexample__named__forward.sin(_3::Float64)::Float64
│   %3 = Base.mul_float(-1.0, %2)::Float64
│        invoke Main.__atexample__named__forward.sin(%1::Float64)::Float64
│   %5 = invoke Main.__atexample__named__forward.cos(%1::Float64)::Float64
│   %6 = Base.mul_float(%3, %5)::Float64
└──      return %6
) =&gt; Float64</pre><p>What of data structures, control flow, function calls? Although these things are all present in Julia&#39;s internal &quot;Wengert list&quot;, they end up being the same in the tangent program as in the primal; so an operator overloading approach need not deal with them explicitly to do the right thing. This won&#39;t be true when we come to talk more about reverse mode, which demands a more complex approach.</p><h2 id="Perturbation-Confusion"><a class="docs-heading-anchor" href="#Perturbation-Confusion">Perturbation Confusion</a><a id="Perturbation-Confusion-1"></a><a class="docs-heading-anchor-permalink" href="#Perturbation-Confusion" title="Permalink"></a></h2><p>Actually, that&#39;s not quite true. Operator-overloading-based forward mode <em>almost always</em> does the right thing, but it is not flawless. This more advanced section will talk about nested differentiation and the nasty bug that can come with it.</p><p>We can differentiate any function we want, as long as we have the right primitive definitions for it. For example, the derivative of <span>$\sin(x)$</span> is <span>$\cos(x)$</span>.</p><pre><code class="language-julia">D(sin, 0.5), cos(0.5)</code></pre><pre class="documenter-example-output">(0.8775825618903728, 0.8775825618903728)</pre><p>We can also differentiate the differentiation operator itself. We&#39;ll find that the second derivative of <span>$\sin(x)$</span> is <span>$-\sin(x)$</span>.</p><pre><code class="language-julia">D(x -&gt; D(sin, x), 0.5), -sin(0.5)</code></pre><pre class="documenter-example-output">(-0.479425538604203, -0.479425538604203)</pre><p>This worked because we ended up nesting dual numbers. If we create a dual number whose <span>$\epsilon$</span> component is another dual number, then we end up tracking the derivative of the derivative.</p><p>The issue comes about when we close over a variable that <em>is itself</em> being differentiated.</p><pre><code class="language-julia">D(x -&gt; x*D(y -&gt; x+y, 1), 1) # == 1</code></pre><pre class="documenter-example-output">2</pre><p>The derivative <span>$\frac{d}{dy} (x + y) = 1$</span>, so this is equivalent to <span>$\frac{d}{dx}x$</span>, which should also be <span>$1$</span>. So where did this go wrong? The problem is that when we closed over <span>$x$</span>, we didn&#39;t just get a numeric value but a dual number with <span>$\epsilon = 1$</span>. When we then calculated <span>$x + y$</span>, both epsilons were added as if <span>$\frac{dx}{dy} = 1$</span> (effectively <span>$x = y$</span>). If we had written this down, the answer would be correct.</p><pre><code class="language-julia">D(x -&gt; x*D(y -&gt; y+y, 1), 1)</code></pre><pre class="documenter-example-output">2</pre><p>I leave this second example as an excercise to the reader. Needless to say, this has caught out many an AD implementor.</p><pre><code class="language-julia">D(x -&gt; x*D(y -&gt; x*y, 1), 4) # == 8</code></pre><pre class="documenter-example-output">5</pre><h2 id="More-on-Dual-Numbers"><a class="docs-heading-anchor" href="#More-on-Dual-Numbers">More on Dual Numbers</a><a id="More-on-Dual-Numbers-1"></a><a class="docs-heading-anchor-permalink" href="#More-on-Dual-Numbers" title="Permalink"></a></h2><p>The above discussion presented dual numbers as essentially being a trick for applying the chain rule. I wanted to take the opportunity to present an alternative viewpoint, which might be appealing if, like me, you have any training in physics.</p><p>Complex arithmetic involves a new number, <span>$i$</span>, which behaves like no other: specifically, because <span>$i^2 = -1$</span>. We&#39;ll introduce a number called <span>$\epsilon$</span>, which is a bit like <span>$i$</span> except that <span>$\epsilon^2 = 0$</span>; this is effectively a way of saying the <span>$\epsilon$</span> is a very small number. The relevance of this comes from the original definition of differentiation, which also requires <span>$\epsilon$</span> to be very small.</p><p class="math-container">\[\frac{d}{dx} f(x) = \lim_{\epsilon \to 0} \frac{f(x+\epsilon)-f(x)}{\epsilon}\]</p><p>We can see how our definition of <span>$\epsilon$</span> works out by applying it to <span>$f(x+\epsilon)$</span>; let&#39;s say that <span>$f(x) = sin(x^2)$</span>.</p><p>\begin{align} f(x + \epsilon) &amp;= \sin((x + \epsilon)^2) \
                &amp;= \sin(x^2 + 2x\epsilon + \epsilon^2) \
                &amp;= \sin(x^2 + 2x\epsilon) \
                &amp;= \sin(x^2)\cos(2x\epsilon) + \cos(x^2)\sin(2x\epsilon) \
                &amp;= \sin(x^2) + 2x\cos(x^2)\epsilon \
\end{align}</p><p>A few things have happened here. Firstly, we directly expand <span>$(x+\epsilon)^2$</span> and remove the <span>$\epsilon^2$</span> term. We expand <span>$sin(a+b)$</span> and then apply a <em>small angle approximation</em>: for small <span>$\theta$</span>, <span>$\sin(\theta) \approx \theta$</span> and <span>$\cos(\theta) \approx 1$</span>. (This sounds pretty hand-wavy, but does follow from our original definition of <span>$\epsilon$</span> if we look at the Taylor expansion of both functions). Finally we can plug this into our derivative rule.</p><p>\begin{align} \frac{d}{dx} f(x) &amp;= \frac{f(x+\epsilon)-f(x)}{\epsilon} \
                  &amp;= 2x\cos(x^2) \end{align}</p><p>This is, in my opinion, a rather nice way to derive functions by hand.</p><p>This also leads to another nice trick, and a third way to look at forward-mode AD; if we replace <span>$x + \epsilon$</span> with <span>$x + \epsilon i$</span> then we still have <span>$(\epsilon i)^2 = 0$</span>. If <span>$\epsilon$</span> is a small real number (say <span>$1\times10^{-10}$</span>), this is still true within floating point error, so our derivative still works out.</p><pre><code class="language-julia">ϵ = 1e-10im
x = 0.5

f(x) = sin(x^2)

(f(x+ϵ) - f(x)) / ϵ</code></pre><pre class="documenter-example-output">0.9689124217106447 - 0.0im</pre><pre><code class="language-julia">2x*cos(x^2)</code></pre><pre class="documenter-example-output">0.9689124217106447</pre><p>So complex numbers can be used to get exact derivatives! This is very efficient and can be written using only one call to <code>f</code>.</p><pre><code class="language-julia">imag(f(x+ϵ)) / imag(ϵ)</code></pre><pre class="documenter-example-output">0.9689124217106447</pre><p>Another way of looking at this is that we are doing bog-standard numerical differentiation, but the use of complex numbers avoids the typical problem with that technique (i.e. that a small perturbation ends up being overwhelmed by floating point error). The dual number is then a slight variation which makes the limit <span>$\epsilon \rightarrow 0$</span> exact, rather than approximate. Forward mode AD can be described as &quot;just&quot; a clever implementation of numerical differentiation. Both numerical and forward derivatives propagate a perturbation <span>$\epsilon$</span> using the same basic rules, and they have the same algorithmic properties.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../backandforth/">« Back &amp; Forth</a><a class="docs-footer-nextpage" href="../tracing/">Tracing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Friday 9 July 2021 03:52">Friday 9 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
